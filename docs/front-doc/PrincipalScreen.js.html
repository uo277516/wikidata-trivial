<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: PrincipalScreen.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: PrincipalScreen.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import '../App.css';
import {Layout, Typography, Image, Input, Form, Button, Alert, Spin, Result, Radio, Modal, notification, Popconfirm,
   Card, Statistic, DatePicker
} from 'antd';
import logo from '../logo.png'; 
import React, { useEffect, useState } from 'react';
import { SmileOutlined,SolutionOutlined,FireOutlined } from '@ant-design/icons';
import { fetchQuestionsFootballers, fetchQuestionsResearchers, editEntity, fetchQuestionsGroups, checkProperties } from '../services/questionsService.js';
import { headerStyle, contentStyle, footerStyle, formStyle , popconfirmStyle} from '../styles/appStyle.js';
import QuestionCard from './QuestionCard.js';
import axios from 'axios';
import MenuComponent from './MenuComponent.js';
import TableComponent from './TableComponent.js';
import { useTranslation } from 'react-i18next';
import dayjs from 'dayjs';
import '../styles/styles.css'; 


//layout ant letters
const {Title, Paragraph, Link} = Typography;
const { Header, Footer, Sider, Content } = Layout;


/**
 * PrincipalScreen component. It has all the funcionality for the game itself.
 * @param {Object} props - Component props.
 * @param {string} props.category - Selected category to do the questions about.
 * @param {string[]} props.categories - List of available categories.
 * @param {Object} props.user - User object containing user information.
 * @returns {React.JSX.Element} Rendered component.
 */
let PrincipalScreen = (props) => {
  let {category, categories, user} = props;
  const { t } = useTranslation();

  let [popOpen, setPopOpen] = useState(false);

  //state variables for maning the questions. Information of the questions
  const [answeredQuestions, setAnsweredQuestions] = useState(0); //for the number of answered questions
  let [questionSelected, setQuestionSelected] = useState(null);
  let [entitySelected, setEntitySelected] = useState(null);
  let [relationSelected, setRelationSelected] = useState(null);
  let [labelSelected, setLabelSelected] = useState(null);
  let [imagenUrl, setImagenUrl] = useState(null);

  const [api, contextHolder] = notification.useNotification();

  const [loading, setLoading] = useState(false); //check if the question is loading
  const [form] = Form.useForm();

  //to check give up
  const [msgChangeGiveUp, setMsgChangeGiveUp] = useState(null);
  const [titleChangeGiveUp, setTitleChangeGiveUp] = useState(null);
  const [giveup, setGiveUp] = useState(false); 

  const [questionError, setQuestionError] = useState(false); //when its a error on the questions

  //categories
  let  selCategory  = category;
  const [selectedCategory, setSelectedCategory] = useState(selCategory);

  //for the loading wheel
  const [loadings, setLoadings] = useState([]);
  const [loadingSend, setLoadingSend] = useState(false);

  //for the clasification
  const [streaks, setStreaks] = useState([])
  const [seeStreaks, setSeeStreaks] = useState(false);

  //for the date picker
  const [answerIsYear, setAnswerIsYear] = useState(false);
  const minDate = dayjs(`1900-01-01`);
  const maxDate = dayjs(`2024-12-31`);
  

  /**
   * Fetches user's streaks for the selected category from the backend.
   * @async
   * @function fetchStreaks
   * @returns {Promise&lt;void>}
   */
  const fetchStreaks = async () => {
    try {
      const response = await axios.get(`http://localhost:3001/getStreaks/${user._json.username}`);
      setStreaks(response.data);
    } catch (error) {
      console.error('Error fetching streaks:', error);
      notification.error({message: t('streak.error'), description: t('streak.error.description'), placement: 'top'});
    }
  };

  /**
   * Saves user's streak for the selected category to the backend.
   * @async
   * @function saveStreak
   * @returns {Promise&lt;void>}
   */
  const saveStreak = async () => {
    try {
      await axios.post('http://localhost:3001/saveStreak', {
        username: user._json.username,
        category: selectedCategory,
        streak: answeredQuestions,
      });
    } catch (error) {
      console.error('Error saving streak:', error);
      notification.error({message: t('streak.error'), description: t('streak.error.description'), placement: 'top'});
    }
  };


  /**
   * Lifecycle hook for fetching initial data on component mount.
   * @function useEffect
   * @returns {void}
   */
  useEffect(() => {
    fetchStreaks();
    if (answeredQuestions>0)
      saveStreak();
  }, []);


  /**
   * Checks user's streak and shows a notification if a new record is achieved.
   * @function checkStreak
   * @returns {void}
   */
  const checkStreak = () => {
    fetchStreaks();
    const firstStreak = streaks.length > 0 ? streaks[0].streak : null;
    let placement='bottom';
    if (firstStreak&lt;answeredQuestions+1) {
      api.success({
        message: t('question.record'),
        description: t('question.record.description', { firstStreak }), 
        placement,
      });
    }
  }

  /**
   * Sets the selected category.
   * @function setSelCategory
   * @param {cc} - Category to change to.
   * @returns {void}
   */
  const setSelCategory = (cc) => {
    selCategory= cc;
  };
  

  /**
   * Fetches the questions based on the selected category.
   * @async
   * @function fetchQuestions
   * @returns {Promise&lt;void>}
   */
  const fetchQuestions = () => {

    const categoryToFetchFunction = {
      investigación: fetchQuestionsResearchers,
      deporte: fetchQuestionsFootballers,
      música: fetchQuestionsGroups
    };
  
    const fetchFunction = categoryToFetchFunction[selectedCategory];
  
    if (fetchFunction) {
      console.log("Loading questions of..." + selectedCategory);
      setLoading(true); 
      fetchFunction()
        .then( ({question, entity, relation, imagenUrl, labelEntity}) => {
          setQuestionSelected(question);
          setEntitySelected(entity);
          setRelationSelected(relation);
          setImagenUrl(imagenUrl);
          setLabelSelected(labelEntity);
          if (question.includes('año') || question.includes('year')) {
            setAnswerIsYear(true);
          } else {
            setAnswerIsYear(false);
          }
        })
        .catch(error => {
          notification.error({message: t('question.error'), description: t('question.error.description'), placement: 'top'});
          setQuestionError(true);
        })
        .finally(() => {
          setLoading(false);
        });
    } else {
      console.error('Category not valid', selectedCategory);
    }
  };
  
  /**
   * Lifecycle hook for fetching initial data on component mount.
   * @function useEffect
   * @returns {void}
   */
  useEffect(() => {
      fetchQuestions();
      console.log("Loading page... :P");
  }, []);
  

  /**
   * Handles the loading state.
   * @function handleLoadingState
   * @param {boolean} state - New loading state value.
   * @returns {void}
   */
  const handleLoadingState = (loading) => {
    setLoadings((prevLoadings) => {
      const newLoadings = [...prevLoadings];
      newLoadings[0] = loading;
      return newLoadings;
    });
    setLoadingSend(loading);
  };

  /**
   * Opens the pop when it is sended the answer.
   * @function openPop
   * @async
   * @returns {void}
   */
  const openPop = async () => {
    try {
      const values = await form.validateFields(); 
      if (values.respuesta &amp;&amp; values.urldereferencia) {
        setPopOpen(true);
      }
    } catch (error) {
      if (error.errorFields.length===0) {
        setPopOpen(true);
      }
      notification.error({message: t('form.error'), description: t('form.error.description'), placement: 'top'});
    }
  };

  /**
   * Handles the loading state of buttons and sends the user's response to the server.
   * @async
   * @function handleSend
   * @param {Function} func - Function to execute after sending the response.
   * @returns {Promise&lt;void>}
   */
  const handleSend = async (func) => {
    try {
      const values = await form.validateFields(); 
      if (values.respuesta &amp;&amp; values.urldereferencia) {
        if (answerIsYear) {
          values.respuesta = values.respuesta.year();
        }
        
        handleLoadingState(true);
        setPopOpen(false);

        // Example of API call (commented out for testing purposes)
        try {
          //await editEntity(selectedCategory, entitySelected, relationSelected.substring(1), values.respuesta, values.urldereferencia, user.oauth.token, user.oauth.token_secret);
          await asyncTestFunction();
          notification.info({message: t('question.send'), 
            description: t('question.sendDescription'), placement: 'topRight'});
          setAnsweredQuestions(answeredQuestions + 1);
        } catch (error) {
          notification.error({message: t('question.noSend'), 
            description: t('question.noSendDescription'), placement: 'topRight'});
        }

        handleLoadingState(false);
        form.resetFields();
        await func();
        checkStreak();
      } else {
        console.error("One or more fields are incomplete.");
      }
    } catch (error) {
      notification.error({message: t('form.error'), description: t('form.error.description'), placement: 'top'});
      console.error('Error in form validation:', error);
    }
  }

  /**
   * Handles the sending of responses when the user chooses to change the entity.
   * @async
   * @function handleSendButton
   * @returns {Promise&lt;void>}
   */
  const handleSendButton = async () => {
    handleSend(fetchQuestions);
  };

  /**
   * Handles the sending of responses when the user chooses to get the questions of the same entity.
   * @async
   * @function handleSendSameEntityButton
   * @returns {Promise&lt;void>}
   */
  const handleSendSameEntityButton = async () => {
    setLoading(true);
    handleSend(funcProperties);
  };  


  /**
   * Checks entity properties and updates the relation selected.
   * @async
   * @function funcProperties
   * @returns {Promise&lt;void>}
   */
  const funcProperties = async () => {
    try {
      const properties = await checkProperties(entitySelected, selectedCategory);
      if (properties) {
        setRelationSelected(properties[0]);
        setLoading(false);
      } else {
        notification.error({message: t('question.error.entity')
        , description: t('question.error.entityDescrip'), placement: 'top'});
        fetchQuestions();
      }
    } catch (error) {
      console.error('Error calling checkProperties:', error);
    }
  }; 


  /**
   * Method for tests of send the answer
   * @async
   * @function asyncTestFunction
   * @returns {Promise&lt;void>}
   */
  const asyncTestFunction = async () => {
    console.log("Initiating asynchronous operation...");
    await new Promise(resolve => setTimeout(resolve, 3000)); 
    console.log("Asynchronous operation completed.");
    // throw new Error("Test error");
  };
  
  

  /**
   * Handles the user giving up on a question.
   * @function handleGiveUp
   * @returns {void}
   */
  const handleGiveUp = () => {
    setTitleChangeGiveUp(t('question.giveup'))
    setMsgChangeGiveUp(t('question.msgGiveUp', { answeredQuestions }));
    if (answeredQuestions>0) {
      saveStreak();
      fetchStreaks();
    }
    setGiveUp(true);
  }

  /**
   * Handles the restart of the game.
   * @function handleRestart
   * @returns {void}
   */
  const handleRestart = () => {
    form.resetFields();
    setAnsweredQuestions(0);
    setGiveUp(false);
    fetchQuestions(selectedCategory);
  };

  /**
   * Sets the selected category and triggers confirmation modal to change category.
   * @function handleCategoryChange
   * @param {string} value - New selected category value.
   * @returns {void}
   */
  const handleCategoryChange = (value) => {
    Modal.confirm({
      title: t('question.changeCat'),
      content: t('question.changeCatContent'),
      onOk: () => {        
        setGiveUp(true);
        setSelectedCategory(value);
        setSelCategory(value);
        setTitleChangeGiveUp(t('question.youChangeCat'))
        setMsgChangeGiveUp(t('question.youChangeCatMsg', { answeredQuestions }));

        //save streak
        if (answeredQuestions>0) {
          saveStreak();
          fetchStreaks();
        }

        setQuestionError(false);
      },
      onCancel: () => {},
      footer: (_, { CancelBtn, OkBtn }) => (
        &lt;>
          &lt;CancelBtn/>
          &lt;OkBtn/>
        &lt;/>
      ),
    });
  };



  return (
    &lt;Layout style={{ minHeight: "100vh" }}>

      {/* Menu */}
      &lt;MenuComponent user={user} mode='horizontal'>&lt;/MenuComponent>

      &lt;Header style={headerStyle}>


      &lt;Layout id='header' style={{ display: 'flex', alignItems: 'center', backgroundColor: 'white'}}>
        
        {/* Info and logo */}
        &lt;Sider style={{ width: '20%', textAlign: 'center', lineHeight: '120px', color: '#fff', backgroundColor: 'white', paddingTop: '20px' }}>
          &lt;Image
            width={200}
            src={logo}
            style={{ paddingLeft: '10px',marginBottom: '20px' }}
            alt='Logo image'
          />
        &lt;/Sider>
        &lt;Content id='content' style={{ flex: 1, textAlign: 'left', paddingLeft: '20px', color: 'black', backgroundColor: 'white'}}>
          &lt;Title level={1} style={{ marginTop: '20px' ,fontWeight: 'bold' }}>Wiki Trivial&lt;/Title>
          &lt;Title level={2} style={{ marginTop: '5px'}}>{t('login.title')}&lt;/Title>
        &lt;/Content>
      &lt;/Layout>

         
          
      &lt;/Header>
      &lt;Content style={contentStyle}>

        &lt;Layout>

          &lt;Content width="100%" style={contentStyle}>   

            {!giveup &amp;&amp; (
              &lt;div style={{paddingTop: 0}}>
                &lt;div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  paddingBottom: '30px'
                  }}>
                  &lt;Radio.Group 
                    value={selectedCategory} 
                    //onChange={(e) => handleCategoryChange(e.target.value)}
                    disabled={loading || loadingSend}>

                    {categories.map((category) => (
                      &lt;Radio.Button key={category} value={category} onClick={() => handleCategoryChange(category)}>
                        {t(`table.${category}`)}
                      &lt;/Radio.Button>
                    ))}
                  &lt;/Radio.Group>
                  &lt;div style={{ display: 'flex', justifyContent: 'flex-end', gap: '10px', marginRight:'0.5vw' }}>
                    &lt;Modal
                        title={t('cat.tableTitle')}
                        open={seeStreaks}
                        onCancel={() => setSeeStreaks(false)}
                        footer={null}
                        width={900}
                    >
                      &lt;TableComponent user={user}>&lt;/TableComponent>
                    &lt;/Modal>
                    &lt;Button style={{marginLeft:'50px'}} 
                      type="primary" icon={&lt;SolutionOutlined />} size='large' onClick={()=>setSeeStreaks(true)}>
                        {t('cat.buttonClasification')}
                      &lt;/Button>
                    
                  &lt;/div>

                &lt;/div>

                &lt;Paragraph style={{fontSize:"20px"}}>
                {t('question.info', { selectedCategory: t(`table.${selectedCategory}`) })}
                  &lt;Link href="https://www.wikidata.org/?uselang=es" target="_blank" style={{fontSize:"20px"}}>Wikidata&lt;/Link>
                  {t('question.info2')}
                &lt;/Paragraph>


                {loading ? (
                    &lt;Spin spinning={true} delay={500} style={{ marginBottom: "20px", width: 700, maxWidth:'100%' }}>
                        &lt;Alert
                            style={{ marginBottom: "20px", width: 700, maxWidth:'100%'}}
                            type="info"
                            message={t('question.load')}
                            description={t('question.wait')}
                        />
                    &lt;/Spin>
                ) : (
                    questionError ? (
                        &lt;Alert
                            style={{ marginBottom: "20px",width: 700, maxWidth:'100%' }}
                            type="error"
                            message={t('question.errorLoad', { selectedCategory })}
                            description={t('question.errorLoadDes')}
                        />
                    ) : (
                        questionSelected &amp;&amp; (
                            &lt;QuestionCard imagenUrl={imagenUrl} questionSelected={questionSelected} relationSelected={relationSelected}
                            label={labelSelected} entity={entitySelected}/>
                        )
                    )
                )}


              &lt;/div>
            )}
              
            

            {giveup ? (
              &lt;Result
              icon={&lt;SmileOutlined />}
              title={titleChangeGiveUp}
              subTitle={msgChangeGiveUp}
              extra={[
                &lt;Button type="primary" key="console" onClick={handleRestart}>
                  {t('question.beginAgain')}
                &lt;/Button>,
              ]}
              />
              ): (              
              
              &lt;div id='form' style={{ paddingTop: '20px', display: 'flex', alignItems: 'flex-start' }}>
                &lt;Form
                    form={form}
                    name="basic"
                    style={{ maxWidth: 700 , flex: 1}}
                    initialValues={{ remember: true }}
                    autoComplete="off"
                    disabled={loading || questionError || loadingSend}
                  >
                    &lt;Form.Item style={formStyle}
                      label={t('answer')}
                      name="respuesta"
                      rules={[
                        { required: true, message: t('question.required') }
                      ]}
                      >
                      {answerIsYear ? (
                        &lt;DatePicker 
                          placeholder={t('question.selectYear')} 
                          minDate={minDate}
                          maxDate={maxDate}
                          style={{ width: '300px' }} 
                          />
                      ) : (
                        &lt;Input placeholder={t('question.answer')} />
                      )}
                    &lt;/Form.Item>

                    &lt;Form.Item style={formStyle}
                      label={t('question.url')}
                      name="urldereferencia"
                      rules={[
                        {required:true, message: t('question.urlRequired') },
                        { type: 'url', message: t('question.urlValid') }
                      ]}
                    >
                      &lt;Input placeholder={t('question.urlExample')}>&lt;/Input>
                    &lt;/Form.Item>

                    &lt;Form.Item >
                      
                    &lt;Popconfirm
                        placement='rightTop'
                        title={t('question.popChangeEntity')}
                        description={t('question.popChangeEntityDescription', {labelSelected})}
                        onConfirm={handleSendSameEntityButton}
                        onCancel={handleSendButton}
                        okText={t('question.continueEntity')}
                        cancelText={t('question.changeEntity')}
                        overlayStyle={popconfirmStyle} 
                        open={popOpen}
                    >&lt;/Popconfirm>
                    &lt;Button type="primary" htmlType="submit" 
                      style={{ marginRight: '20px'}} loading={loadings[0]} onClick={openPop}>
                      {t('question.buttonSend')}
                    &lt;/Button>


                      &lt;Popconfirm
                        title={t('question.popGiveUp')}
                        description={t('question.sureGiveUp')}
                        onConfirm={handleGiveUp}
                        okText={t('yes')}
                        cancelText={t('no')}
                      >
                        &lt;Button id='btn_gu' type="primary">
                          {t('question.popGiveUp')}
                        &lt;/Button>
                        
                      &lt;/Popconfirm>
                      
                    &lt;/Form.Item>

                  &lt;/Form>

                  &lt;Card id='card' bordered={true} style={{marginLeft: '80px'}}>
                    &lt;Statistic
                      title={t('question.ranking')}
                      value={answeredQuestions}
                      precision={0}
                      valueStyle={{ color: '#3f8600' }}
                      prefix={&lt;FireOutlined />}
                    />
                  &lt;/Card>

              &lt;/div>
            )}
            
            &lt;Content style={{marginBottom:'13px'}} >
            &lt;/Content>
          &lt;/Content>
          
        &lt;/Layout>

      &lt;/Content>
      
      &lt;Footer style={footerStyle}> {t('footer.info')}&lt;a href="https://www.icons8.com" target="_blank" rel="noopener noreferrer" style={{ color: 'white', textDecoration: 'underline' }}>Icons8&lt;/a>&lt;/Footer>
    &lt;/Layout>
  );
}

export default PrincipalScreen;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#CategorySelectionPage">CategorySelectionPage</a></li><li><a href="global.html#LoginComponent">LoginComponent</a></li><li><a href="global.html#MenuComponent">MenuComponent</a></li><li><a href="global.html#PrincipalScreen">PrincipalScreen</a></li><li><a href="global.html#QuestionCard">QuestionCard</a></li><li><a href="global.html#TableComponent">TableComponent</a></li><li><a href="global.html#asyncTestFunction">asyncTestFunction</a></li><li><a href="global.html#cancel">cancel</a></li><li><a href="global.html#changeLanguage">changeLanguage</a></li><li><a href="global.html#checkAuthentication">checkAuthentication</a></li><li><a href="global.html#checkStreak">checkStreak</a></li><li><a href="global.html#fetchQuestions">fetchQuestions</a></li><li><a href="global.html#fetchStreaks">fetchStreaks</a></li><li><a href="global.html#fetchUserData">fetchUserData</a></li><li><a href="global.html#filterStreaks">filterStreaks</a></li><li><a href="global.html#funcProperties">funcProperties</a></li><li><a href="global.html#handleCategoryChange">handleCategoryChange</a></li><li><a href="global.html#handleGiveUp">handleGiveUp</a></li><li><a href="global.html#handleLoadingState">handleLoadingState</a></li><li><a href="global.html#handleLogin">handleLogin</a></li><li><a href="global.html#handleRestart">handleRestart</a></li><li><a href="global.html#handleSegmentedChange">handleSegmentedChange</a></li><li><a href="global.html#handleSend">handleSend</a></li><li><a href="global.html#handleSendButton">handleSendButton</a></li><li><a href="global.html#handleSendSameEntityButton">handleSendSameEntityButton</a></li><li><a href="global.html#handleStartGame">handleStartGame</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#ok">ok</a></li><li><a href="global.html#openPop">openPop</a></li><li><a href="global.html#saveStreak">saveStreak</a></li><li><a href="global.html#setSelCategory">setSelCategory</a></li><li><a href="global.html#useEffect">useEffect</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Thu Jun 20 2024 23:08:59 GMT+0200 (hora de verano de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
